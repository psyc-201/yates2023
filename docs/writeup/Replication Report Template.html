<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Replication Author[s]: Anna Pusok (annapusok@ucsd.edu)">
<meta name="dcterms.date" content="2025-11-05">

<title>Replication of Study Robust holistic face processing in early childhood during the COVID-19 pandemic by Yates &amp; Lewkowicz (2023, Journal of Experimental Child Psychology)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-838cb846b2414f11caac439a21f6b75f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#power-analysis" id="toc-power-analysis" class="nav-link" data-scroll-target="#power-analysis">Power Analysis</a></li>
  <li><a href="#planned-sample" id="toc-planned-sample" class="nav-link" data-scroll-target="#planned-sample">Planned Sample</a></li>
  <li><a href="#materials" id="toc-materials" class="nav-link" data-scroll-target="#materials">Materials</a></li>
  <li><a href="#procedure" id="toc-procedure" class="nav-link" data-scroll-target="#procedure">Procedure</a></li>
  <li><a href="#analysis-plan" id="toc-analysis-plan" class="nav-link" data-scroll-target="#analysis-plan">Analysis Plan</a></li>
  <li><a href="#differences-from-original-study" id="toc-differences-from-original-study" class="nav-link" data-scroll-target="#differences-from-original-study">Differences from Original Study</a></li>
  <li><a href="#methods-addendum-post-data-collection" id="toc-methods-addendum-post-data-collection" class="nav-link" data-scroll-target="#methods-addendum-post-data-collection">Methods Addendum (Post Data Collection)</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a>
  <ul class="collapse">
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation">Data preparation</a></li>
  <li><a href="#confirmatory-analysis" id="toc-confirmatory-analysis" class="nav-link" data-scroll-target="#confirmatory-analysis">Confirmatory analysis</a></li>
  <li><a href="#exploratory-analyses" id="toc-exploratory-analyses" class="nav-link" data-scroll-target="#exploratory-analyses">Exploratory analyses</a></li>
  </ul></li>
  <li><a href="#load-libraries" id="toc-load-libraries" class="nav-link" data-scroll-target="#load-libraries">Load libraries</a></li>
  <li><a href="#set-working-directory-to-where-your-csv-files-are" id="toc-set-working-directory-to-where-your-csv-files-are" class="nav-link" data-scroll-target="#set-working-directory-to-where-your-csv-files-are">Set working directory to where your CSV files are</a></li>
  <li><a href="#read-and-combine-all-csv-files" id="toc-read-and-combine-all-csv-files" class="nav-link" data-scroll-target="#read-and-combine-all-csv-files">Read and combine all CSV files</a></li>
  <li><a href="#display-basic-info" id="toc-display-basic-info" class="nav-link" data-scroll-target="#display-basic-info">Display basic info</a></li>
  <li><a href="#filter-main-task-trials-only-exclude-practice-and-other-non-trial-rows" id="toc-filter-main-task-trials-only-exclude-practice-and-other-non-trial-rows" class="nav-link" data-scroll-target="#filter-main-task-trials-only-exclude-practice-and-other-non-trial-rows">Filter main task trials only (exclude practice and other non-trial rows)</a></li>
  <li><a href="#create-alignment-and-correct_response-variables" id="toc-create-alignment-and-correct_response-variables" class="nav-link" data-scroll-target="#create-alignment-and-correct_response-variables">Create alignment and correct_response variables</a></li>
  <li><a href="#accuracy-analysis" id="toc-accuracy-analysis" class="nav-link" data-scroll-target="#accuracy-analysis">===== ACCURACY ANALYSIS =====</a></li>
  <li><a href="#calculate-accuracy-by-subject-and-condition" id="toc-calculate-accuracy-by-subject-and-condition" class="nav-link" data-scroll-target="#calculate-accuracy-by-subject-and-condition">Calculate accuracy by subject and condition</a></li>
  <li><a href="#overall-means-and-ses" id="toc-overall-means-and-ses" class="nav-link" data-scroll-target="#overall-means-and-ses">Overall means and SEs</a></li>
  <li><a href="#statistical-tests-for-accuracy" id="toc-statistical-tests-for-accuracy" class="nav-link" data-scroll-target="#statistical-tests-for-accuracy">Statistical tests for accuracy</a></li>
  <li><a href="#accuracy-plot" id="toc-accuracy-plot" class="nav-link" data-scroll-target="#accuracy-plot">Accuracy plot</a>
  <ul class="collapse">
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a>
  <ul class="collapse">
  <li><a href="#summary-of-replication-attempt" id="toc-summary-of-replication-attempt" class="nav-link" data-scroll-target="#summary-of-replication-attempt">Summary of Replication Attempt</a></li>
  <li><a href="#commentary" id="toc-commentary" class="nav-link" data-scroll-target="#commentary">Commentary</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Replication of Study Robust holistic face processing in early childhood during the COVID-19 pandemic by Yates &amp; Lewkowicz (2023, Journal of Experimental Child Psychology)</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Replication Author[s]: Anna Pusok (annapusok@ucsd.edu) </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- Replication reports should all use this template to standardize reporting across projects.  These reports will be public supplementary materials that accompany the summary report(s) of the aggregate results. -->
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Autism spectrum disorder (ASD) is characterized by difficulties in social communication, repetitive behaviors and restricted interests. A fundamental aspect of social communication is face perception, which has been extensively studied in ASD research. The composite face effect (CFE; Young et al., 1987) is a measure of holistic face processing, and typically developing children show evidence of the CFE as early as four years of age. In contrast, individuals with ASD often exhibit atypical face processing, thought to stem from reduced holistic perception and employing more feature-based strategies. However, holistic face processing is cruical for social communication processes, such as emotion recognition. Although several studies have examined the CFE in adolescents and adults with ASD, findings have been inconsistent. To date, however, no research has investigated the CFE in young children with ASD. My first year project aims to fill this gap by testing holistic face processing in young children with ASD. As a first step, for my statistics project, I want to pilot the task with neurotypical adults to validate the paradigm and ensure the procedure is feasible before extending it to child populations. Yates &amp; Lewkowicz tested the CFE paradigm in children ages 4-6, with findings that kids as young as 4 exhibit holistic face processing, so I am planning to replicate their study.</p>
<p>For the stimuli, I plan to use a Caucasian hairless faces (male and female) with neutral expressions, from the Chicago Face Database. The face images will be grayscale displayed on a white screen, and the top parts of the faces will be highlighted, consistent with prior (Yates &amp; Lewkowicz, 2023). Yates &amp; Lewkowicz presented 36 trials, for the adult sample, I plan to do more based on power analysis. //I will meet with Jane to discuss what is the best number of trials for the experiment based on power analysis. I do plan to use different analysis methods once I collect both neurotypical and ASD data given that Yates &amp; Lewkowicz only had neurotypical kid data only and for the class, I’m only collecting neurotypical adult data.</p>
<p>The procedure will include two practice trials, the first one being spatially aligned composite faces where the top halves are of different faces, the other being spatially misaligned with same top halves. Participants will receive feedback during the practice trials, and the experiment only advances forward when participants select the correct choice. The test phase will consist of 2 blocks of 36 test trials with a short break between the blocks.</p>
<p>About 24 neurotypical adult participants will be recruited for the final project. This sample size was according to Hsiung &amp; Chien (2024.) They conducted a power analysis and determined that 24 neurotypical and ASD adults are a good number. I uploaded that paper to my original_paper folder.</p>
<p>The main challenge will be ensuring that participants remain attentive through the trials. For that, I’ll be including an exclusion criteria that if participants said all “same” or all “different” responses, which would be an indicator of not paying attention. Participants who also fail to finish the experiment will also be excluded.</p>
<p>Link to paper: https://github.com/annapusok731/yates2023/tree/2885fd3f36660e431e4876c7b2f4dec89f9b7a79/original_paper</p>
<p>Repository: https://github.com/annapusok731/yates2023.git</p>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<section id="power-analysis" class="level3">
<h3 class="anchored" data-anchor-id="power-analysis">Power Analysis</h3>
<p>I calculated with power for Yates and Lewkowicz (2023) with G-Power. They had power of 1.0 with the effect size of 0.743 and n=128. Based on these analyses, I need an n of 17 to have an actual power of 0.82 (however, I’m hoping to do additional analyses with an additional group {ASD group}, so I did additoonal power analyses bvased on a paper that has done similar task with two groups and got that, I’d need 24 participants in each group.)</p>
</section>
<section id="planned-sample" class="level3">
<h3 class="anchored" data-anchor-id="planned-sample">Planned Sample</h3>
<p>About 24 neurotypical adult (# female gender, # other gender) participants (M age = X years, SD = Y, range = X-Y) will be recruited for the final project. This sample size was according to Hsiung &amp; Chien (2024). “This sample size was calculated according to Rosner et al.&nbsp;(2005) and was determined based on power consideration (i.e., we set the type 1 error (α) to 0.05, the power (1-β) at approximately 0.84, leading to an expected sample size of 24).” Exclusion criteria(s): Participants will also be excluded from analyses if they respond at chance level (50% correct). Responses faster than 200 ms and average response time exceeding ±2 standard deviations from each participant’s mean will also be excluded.</p>
</section>
<section id="materials" class="level3">
<h3 class="anchored" data-anchor-id="materials">Materials</h3>
<p>Composite face stimuli will be created using Canva from the Chicago Face Database at (https://www.chicagofaces.org/). Faces will be grayscale images of White males and females with a neutral expression looking directly into the camera. 48 pairs of composite face stimuli (24 male and 24 female pairs) were presented to each participant. “Given that misalignment of inner face features can reduce the composite face effect (Curby &amp; Entenman, 2016; but see Kurbel et al., 2021, for robust results regardless of perceptual fit), we ensured as much as possible that each individual face was paired with a same-gender face of similar size/shape and skin tone. In addition, as recommended for the composite face task (Rossion &amp; Retter, 2015), we included a small gap between the top and bottom halves of each composite face.”</p>
<p>“For each identity pair, we created 8 different composite faces from combinations of the top and bottom halves of the faces (these can be seen in Fig. 1 A). Four of these composite faces consisted of spatially aligned top and bottom halves of faces, and the other four consisted of spatially misaligned top and bottom halves of faces (in the misaligned composite faces, the top half of the face was shifted ∼1.2 cm to the left of the bottom half of the face). As can be seen in Fig. 1A, Composite Face AA consisted of the top and bottom halves of Identity A, Composite Face AB consisted of the top half of Identity A and the bottom half of Identity B, Composite Face BA consisted of the top half of Identity B and the bottom half of Identity A, and Composite Face BB consisted of the top and bottom halves of Identity B. To minimize the impact of external face features, we removed all hair and ears from the original images by using Adobe Photoshop 2020 and added a slight purple–pink tint to the top halves of the faces to draw children’s attention to the top halves (de Heering et al., 2007). The full stimulus set is available at a public GitHub link: [I’ll add my GitHub repo here once the project is done.]”</p>
</section>
<section id="procedure" class="level3">
<h3 class="anchored" data-anchor-id="procedure">Procedure</h3>
<p>After gaining approval from the Institutional Review Board, participants were recruited through Sona and received course credit for participation. After enrolling through their Sona accounts, participants completed the experiment online.</p>
<p>“The first part of the experiment consisted of two practice trials. During the first of these trials, participants saw a pair of spatially aligned composite faces where the top halves were of different faces. One composite face was presented on one side of the screen, and the other composite face was presented on the other side of the screen.” Adults are asked to decide whether the yellow parts of the faces (i.e., the tops) of these composite faces were the same or different. Participants will receive feedback during the practice trials. Thus an incorrect response will prompt them to “Try Again.” A correct response will confirm their accuracy: “Great job! The yellow parts of the face are the same.” During the second practice trial, participants will see a pair of spatially misaligned composite faces where the top halves were of the same face and were once again asked whether the yellow parts” of these faces were the same or different. Again, if participants made an incorrect choice, they will be prompted to try again, and they got positive response for the correct choice.</p>
<p>After the practice trials are completed, adults were given 72 test trials during which “we presented four different types of stimulus pairs. These pairs were (a) aligned–same, where the top halves of the two composite faces depicted the same identity (e.g., AA and AB) and where the top and bottom halves were horizontally aligned, (b) aligned–different, where the top halves of two composite faces depicted different identities (e.g., BA and AB) and where the top and bottom halves were horizontally aligned, (c) misaligned–same, where the top halves of two composite faces depicted the same identity but were horizontally offset, and (d) misaligned–different, where the top halves of two composite faces depicted different identities but were horizontally offset (Fig. 1A, right). Fig. 1B shows an example of the types of stimuli and response buttons presented during an aligned–same trial.”</p>
<p>“During each trial, participants were prompted to respond whether the faces were the same or different by clicking on one of two buttons visible on the screen corresponding to these choices (see Fig. 1B). Participants were also reminded after 10, 20, and 30 trials that they were supposed to answer whether the”yellow parts” of the face were the same or different. A click of one of the two response buttons was required to advance the experiment to the next trial. Participants had unlimited time to respond.”</p>
<p>Once participants complete the experiment, they will be asked to complete a demographic survey indicating their age, race and ethnicity, highest level of education completed, current employment status and their location defined as “urban,” “suburban” or “rural.” Participants were also asked to complete the Social Responsiveness Scale (SRS-2 Adult) about their social abilities.</p>
</section>
<section id="analysis-plan" class="level3">
<h3 class="anchored" data-anchor-id="analysis-plan">Analysis Plan</h3>
<p>“Response accuracy The data of primary interest were the accuracy scores obtained in the same trials. Specifically, lower accuracy scores in the aligned–same trials than in the misaligned–same trials is generally considered to reflect holistic processing. The data of secondary interest were the accuracy scores obtained in the different trials. In this case, the accuracy scores in the aligned–different trials and in the misaligned–different trials should be the same. These different trial scores indicate how well children were able to detect differences when the top halves of the composite faces actually differed and, thus, provide a baseline against which to evaluate the accuracy data from the same trials. To statistically assess response accuracy, we performed mixed repeated-measures analysis of variance (ANOVA) models with alignment as a within-participants factor, age and gender as between-participants factors, and participant as a random effect. For all analyses, we included gender as a predictor given prior research showing that there may be differences in holistic face processing even in early childhood (Stajduhar et al., 2022).”</p>
</section>
<section id="differences-from-original-study" class="level3">
<h3 class="anchored" data-anchor-id="differences-from-original-study">Differences from Original Study</h3>
<p>My study diverged from Yates and Lewkowicz in a few methodological aspects. Although both studies used the Chicago Face Database, I doubled the stimulus presentation (given that my sample size included adults instead of children), showing participants 48 unique composite face pairs (evenly split between male and female faces) rather than 24. I also modified the attentional cue by replacing the original purple-pink tint applied to top face halves with a yellow tint for enhanced visibility. Additionally, I extended the dependent measures beyond the original study by recording reaction times, establishing RT-based exclusion criteria, and performing supplementary RT related analyses. Finally, I added a demographic questionnaire and the Social Responsiveness Scale (SRS-2 Adult) to assess participants social abilities.</p>
</section>
<section id="methods-addendum-post-data-collection" class="level3">
<h3 class="anchored" data-anchor-id="methods-addendum-post-data-collection">Methods Addendum (Post Data Collection)</h3>
<p>You can comment this section out prior to final report with data collection.</p>
<section id="actual-sample" class="level4">
<h4 class="anchored" data-anchor-id="actual-sample">Actual Sample</h4>
<p>Sample size, demographics, data exclusions based on rules spelled out in analysis plan</p>
</section>
<section id="differences-from-pre-data-collection-methods-plan" class="level4">
<h4 class="anchored" data-anchor-id="differences-from-pre-data-collection-methods-plan">Differences from pre-data collection methods plan</h4>
<p>Any differences from what was described as the original plan, or “none”.</p>
</section>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<section id="data-preparation" class="level3">
<h3 class="anchored" data-anchor-id="data-preparation">Data preparation</h3>
<p>Three exclusion criteria will be applied. First, participants performing at or below chance (50% accuracy) were excluded. Second, participants who completed fewer than [X] trials per condition were removed from analyses (after we have the power analysis class, I’ll add more concrete info here). Third, for reaction time analyses, we excluded individual trials faster than 200 ms and removed participants whose average RT fell more than three standard deviations from their group mean.</p>
</section>
<section id="confirmatory-analysis" class="level3">
<h3 class="anchored" data-anchor-id="confirmatory-analysis">Confirmatory analysis</h3>
<p>Accuracy &amp; RT I plan to do separate mixed-design ANOVAs for accuracy and RT data, with Group (Autism, Control) as the between-subjects factor and Condition (Aligned, Misaligned) as the within-subjects factor. The composite face effect was operationalized as the difference in performance between aligned and misaligned conditions, with a reduced effect in aligned trials indicating holistic face processing. The critical test will be the Group × Condition interaction, which would indicate whether the composite face effect differs between autistic individuals and controls. I also plan to examine main effects of Group and Condition.</p>
<p>SRS I plan to do independent samples t-tests to compare SRS total scores between groups and then compute Pearson correlations between SRS total scores and the composite face effect (accuracy in aligned-same and misaligned-same conditions) to test whether individual differences in autistic symptoms predict holistic face processing.</p>
<p><em>Side-by-side graph with original graph is ideal here</em></p>
</section>
<section id="exploratory-analyses" class="level3">
<h3 class="anchored" data-anchor-id="exploratory-analyses">Exploratory analyses</h3>
<p>Explonatory analyses (as of 11/05/25) (I wrote most of this code with the help of Claude so any suggestions/comments are greatly appreciated.) (See code on my github repo: yates2023/code/prelimanalysis.r)</p>
</section>
</section>
<section id="load-libraries" class="level1">
<h1>Load libraries</h1>
<p>library(tidyverse)</p>
</section>
<section id="set-working-directory-to-where-your-csv-files-are" class="level1">
<h1>Set working directory to where your CSV files are</h1>
<p>setwd(“/Users/annapusok/Desktop/data/”)</p>
</section>
<section id="read-and-combine-all-csv-files" class="level1">
<h1>Read and combine all CSV files</h1>
<p>file_list &lt;- list.files(pattern = “*.csv”) all_data &lt;- map_df(file_list, read_csv)</p>
</section>
<section id="display-basic-info" class="level1">
<h1>Display basic info</h1>
<p>cat(“Total number of files:”, length(file_list), “”) cat(“Total number of rows:”, nrow(all_data), “”) cat(“Number of unique subjects:”, n_distinct(all_data$subject_id), “”)</p>
</section>
<section id="filter-main-task-trials-only-exclude-practice-and-other-non-trial-rows" class="level1">
<h1>Filter main task trials only (exclude practice and other non-trial rows)</h1>
<p>main_data &lt;- all_data %&gt;% filter(task == “main”, !is.na(correct), !is.na(response_time_ms))</p>
</section>
<section id="create-alignment-and-correct_response-variables" class="level1">
<h1>Create alignment and correct_response variables</h1>
<p>main_data &lt;- main_data %&gt;% mutate( alignment = case_when( condition %in% c(“diff_align”, “same_aligned”) ~ “aligned”, condition %in% c(“diff_misalign”, “same_misaligned”) ~ “misaligned” ), correct_response = case_when( condition %in% c(“diff_align”, “diff_misalign”) ~ “different”, condition %in% c(“same_aligned”, “same_misaligned”) ~ “same” ) )</p>
<p>cat(“trials after filtering:”, nrow(main_data), “”)</p>
</section>
<section id="accuracy-analysis" class="level1">
<h1>===== ACCURACY ANALYSIS =====</h1>
<p>cat(“========== ACCURACY ANALYSIS ==========”)</p>
</section>
<section id="calculate-accuracy-by-subject-and-condition" class="level1">
<h1>Calculate accuracy by subject and condition</h1>
<p>accuracy_by_subject &lt;- main_data %&gt;% group_by(subject_id, alignment, correct_response) %&gt;% summarise( accuracy = mean(correct, na.rm = TRUE), n_trials = n(), .groups = “drop” )</p>
</section>
<section id="overall-means-and-ses" class="level1">
<h1>Overall means and SEs</h1>
<p>accuracy_means &lt;- accuracy_by_subject %&gt;% group_by(alignment, correct_response) %&gt;% summarise( mean_accuracy = mean(accuracy), se_accuracy = sd(accuracy) / sqrt(n()), n_subjects = n(), .groups = “drop” )</p>
<p>print(accuracy_means)</p>
</section>
<section id="statistical-tests-for-accuracy" class="level1">
<h1>Statistical tests for accuracy</h1>
<p>cat(“— Accuracy: Different Trials —”) diff_accuracy &lt;- accuracy_by_subject %&gt;% filter(correct_response == “different”) %&gt;% pivot_wider(names_from = alignment, values_from = accuracy, id_cols = subject_id)</p>
<p>if(all(c(“aligned”, “misaligned”) %in% names(diff_accuracy))) { diff_acc_test &lt;- t.test(diff_accuracy<span class="math inline">\(aligned, diff_accuracy\)</span>misaligned, paired = TRUE) print(diff_acc_test) cat(“Effect size (Cohen’s d):”, (mean(diff_accuracy<span class="math inline">\(aligned) - mean(diff_accuracy\)</span>misaligned)) / sd(diff_accuracy<span class="math inline">\(aligned - diff_accuracy\)</span>misaligned), “”) }</p>
<p>cat(“— Accuracy: Same Trials —”) same_accuracy &lt;- accuracy_by_subject %&gt;% filter(correct_response == “same”) %&gt;% pivot_wider(names_from = alignment, values_from = accuracy, id_cols = subject_id)</p>
<p>if(all(c(“aligned”, “misaligned”) %in% names(same_accuracy))) { same_acc_test &lt;- t.test(same_accuracy<span class="math inline">\(aligned, same_accuracy\)</span>misaligned, paired = TRUE) print(same_acc_test) cat(“Effect size (Cohen’s d):”, (mean(same_accuracy<span class="math inline">\(aligned) - mean(same_accuracy\)</span>misaligned)) / sd(same_accuracy<span class="math inline">\(aligned - same_accuracy\)</span>misaligned), “”) }</p>
</section>
<section id="accuracy-plot" class="level1">
<h1>Accuracy plot</h1>
<p>accuracy_plot &lt;- ggplot(accuracy_means, aes(x = alignment, y = mean_accuracy, fill = correct_response)) + geom_bar(stat = “identity”, position = position_dodge(0.9), width = 0.7) + geom_errorbar(aes(ymin = mean_accuracy - se_accuracy, ymax = mean_accuracy + se_accuracy), width = 0.2, position = position_dodge(0.9)) + scale_fill_manual(values = c(“different” = “#38b6ff”, “same” = “#ff914d”), labels = c(“Different”, “Same”)) + labs(title = “Accuracy by Alignment and Response Type”, y = “Accuracy (Proportion Correct)”, x = “Alignment Condition”, fill = “Trial Type”) + theme_minimal(base_size = 14) + theme(legend.position = “top”) + ylim(0, 1)</p>
<p>print(accuracy_plot) ggsave(“accuracy_plot.png”, width = 8, height = 6)</p>
<section id="discussion" class="level2">
<h2 class="anchored" data-anchor-id="discussion">Discussion</h2>
<section id="summary-of-replication-attempt" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-replication-attempt">Summary of Replication Attempt</h3>
<p>Open the discussion section with a paragraph summarizing the primary result from the confirmatory analysis and the assessment of whether it replicated, partially replicated, or failed to replicate the original result.</p>
</section>
<section id="commentary" class="level3">
<h3 class="anchored" data-anchor-id="commentary">Commentary</h3>
<p>Add open-ended commentary (if any) reflecting (a) insights from follow-up exploratory analysis, (b) assessment of the meaning of the replication (or not) - e.g., for a failure to replicate, are the differences between original and present study ones that definitely, plausibly, or are unlikely to have been moderators of the result, and (c) discussion of any objections or challenges raised by the current and original authors about the replication attempt. None of these need to be long.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>